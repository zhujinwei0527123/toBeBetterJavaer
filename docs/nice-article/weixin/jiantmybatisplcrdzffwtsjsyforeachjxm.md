---title: 浅谈MyBatis批量插入的3种方法，10w条数据使用foreach仅需2秒！！shortTitle: 浅谈MyBatis批量插入的3种方法，10w条数据使用foreach仅需2秒！！description: 今天来聊聊 MyBatis 的批量插入，对其 3 种实现方法做一个性能测试，以及相应的原理分析。author: 磊哥category:  - 微信公众号---批量插入功能是我们日常工作中比较常见的业务功能之一，今天咱们来一个 MyBatis 批量插入的汇总篇，同时对 3 种实现方法做一个性能测试，以及相应的原理分析。先来简单说一下 3 种批量插入功能分别是：1.  循环单次插入；2.  MP 批量插入功能；3.  原生批量插入功能。## 准备工作开始之前我们先来创建数据库和测试数据，执行的 SQL 脚本如下：```-- ------------------------------ 创建数据库-- ----------------------------SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;DROP DATABASE IF EXISTS `testdb`;CREATE DATABASE `testdb`;USE `testdb`;-- ------------------------------ 创建 user 表-- ----------------------------DROP TABLE IF EXISTS `user`;CREATE TABLE `user`  (  `id` int(11) NOT NULL AUTO_INCREMENT,  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL,  `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL,  `createtime` datetime NULL DEFAULT CURRENT_TIMESTAMP,  PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_bin ROW_FORMAT = Dynamic;-- ------------------------------ 添加测试数据-- ----------------------------INSERT INTO `user` VALUES (1, '赵云', '123456', '2021-09-10 18:11:16');INSERT INTO `user` VALUES (2, '张飞', '123456', '2021-09-10 18:11:28');INSERT INTO `user` VALUES (3, '关羽', '123456', '2021-09-10 18:11:34');INSERT INTO `user` VALUES (4, '刘备', '123456', '2021-09-10 18:11:41');INSERT INTO `user` VALUES (5, '曹操', '123456', '2021-09-10 18:12:02');SET FOREIGN_KEY_CHECKS = 1;```数据库的最终效果如下：![](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-jiantmybatisplcrdzffwtsjsyforeachjxm-c58f5d09-cd1d-4bc9-9095-286a645acd6c.jpg)## 1.循环单次插入接下来我们将使用 Spring Boot 项目，批量插入 10W 条数据来分别测试各个方法的执行时间。循环单次插入的（测试）核心代码如下：```import com.example.demo.model.User;import com.example.demo.service.impl.UserServiceImpl;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass UserControllerTest {    // 最大循环次数    private static final int MAXCOUNT = 100000;    @Autowired    private UserServiceImpl userService;    /**     * 循环单次插入     */    @Test    void save() {        long stime = System.currentTimeMillis(); // 统计开始时间        for (int i = 0; i < MAXCOUNT; i++) {            User user = new User();            user.setName("test:" + i);            user.setPassword("123456");            userService.save(user);        }        long etime = System.currentTimeMillis(); // 统计结束时间        System.out.println("执行时间：" + (etime - stime));    }}```运行以上程序，花费了 88574 毫秒，如下图所示：![](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-jiantmybatisplcrdzffwtsjsyforeachjxm-9d65d2e5-c528-47ba-a219-79b2797c3207.jpg)## 2.MP 批量插入MP 批量插入功能核心实现类有三个：UserController（控制器）、UserServiceImpl（业务逻辑实现类）、UserMapper（数据库映射类），它们的调用流程如下:![](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-jiantmybatisplcrdzffwtsjsyforeachjxm-d31a8de8-a3de-4e16-8bac-10b0f093c972.jpg)注意此方法实现需要先添加 MP 框架，打开 pom.xml 文件添加如下内容：```<dependency>    <groupId>com.baomidou</groupId>    <artifactId>mybatis-plus-boot-starter</artifactId>    <version>mybatis-plus-latest-version</version></dependency>```> 注意：mybatis-plus-latest-version 表示 MP 框架的最新版本号，可访问 https://mvnrepository.com/artifact/com.baomidou/mybatis-plus-boot-starter 查询最新版本号，但在使用的时候记得一定要将上面的 “mybatis-plus-latest-version”替换成换成具体的版本号，如 3.4.3 才能正常的引入框架。更多 MP 框架的介绍请移步它的官网：https://baomidou.com/guide/### ① 控制器实现```import com.example.demo.model.User;import com.example.demo.service.impl.UserServiceImpl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.ArrayList;import java.util.List;@RestController@RequestMapping("/u")public class UserController {    @Autowired    private UserServiceImpl userService;    /**     * 批量插入（自定义）     */    @RequestMapping("/mysavebatch")    public boolean mySaveBatch(){        List<User> list = new ArrayList<>();        // 待添加（用户）数据        for (int i = 0; i < 1000; i++) {            User user = new User();            user.setName("test:"+i);            user.setPassword("123456");            list.add(user);        }        return userService.saveBatchCustom(list);    }}```### ② 业务逻辑层实现```import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.example.demo.mapper.UserMapper;import com.example.demo.model.User;import com.example.demo.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class UserServiceImpl extends ServiceImpl<UserMapper,User>        implements UserService {    @Autowired    private UserMapper userMapper;    public boolean saveBatchCustom(List<User> list){        return userMapper.saveBatchCustom(list);    }}```### ③ 数据持久层实现```import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.example.demo.model.User;import org.apache.ibatis.annotations.Mapper;import java.util.List;@Mapperpublic interface UserMapper extends BaseMapper<User>{    boolean saveBatchCustom(List<User> list);}```经过以上代码实现，我们就可以使用 MP 来实现数据的批量插入功能了，但本篇除了具体的实现代码之外，我们还要知道每种方法的执行效率，所以接下来我们来编写 MP 的测试代码。### MP 性能测试```import com.example.demo.model.User;import com.example.demo.service.impl.UserServiceImpl;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.util.ArrayList;import java.util.List;@SpringBootTestclass UserControllerTest {    // 最大循环次数    private static final int MAXCOUNT = 100000;    @Autowired    private UserServiceImpl userService;    /**     * MP 批量插入     */    @Test    void saveBatch() {        long stime = System.currentTimeMillis(); // 统计开始时间        List<User> list = new ArrayList<>();        for (int i = 0; i < MAXCOUNT; i++) {            User user = new User();            user.setName("test:" + i);            user.setPassword("123456");            list.add(user);        }        // MP 批量插入        userService.saveBatch(list);        long etime = System.currentTimeMillis(); // 统计结束时间        System.out.println("执行时间：" + (etime - stime));    }}```以上程序的执行总共花费了 6088 毫秒，如下图所示：![](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-jiantmybatisplcrdzffwtsjsyforeachjxm-4a267c42-a363-4dd0-8397-385e58bfc0ee.jpg)从上述结果可知，使用 MP 的批量插入功能（插入数据 10W 条），它的性能比循环单次插入的性能提升了 14.5 倍。### MP 源码分析从 MP 和循环单次插入的执行时间我们可以看出，使用 MP 并不是像有些朋友认为的那样，还是循环单次执行的，为了更清楚的说明此问题，我们查看了 MP 的源码。MP 的核心实现代码是 saveBatch 方法，此方法的源码如下：![](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-jiantmybatisplcrdzffwtsjsyforeachjxm-d3373660-274a-473e-b958-07731fdf9fa5.jpg)我们继续跟进 saveBatch 的重载方法：![](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-jiantmybatisplcrdzffwtsjsyforeachjxm-a8427c2f-7dca-4b15-be72-14c2d9c22563.jpg)从上述源码可以看出，MP 是将要执行的数据分成 N 份，每份 1000 条，每满 1000 条就会执行一次批量插入，所以它的性能要比循环单次插入的性能高很多。那为什么要分批执行，而不是一次执行？别着急，当我们看了第 3 种实现方法之后我们就明白了。## 3.原生批量插入原生批量插入方法是依靠 MyBatis 中的 foreach 标签，将数据拼接成一条原生的 insert 语句一次性执行的，核心实现代码如下。### ① 业务逻辑层扩展在 UserServiceImpl 添加 saveBatchByNative 方法，实现代码如下：```import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.example.demo.mapper.UserMapper;import com.example.demo.model.User;import com.example.demo.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class UserServiceImpl extends ServiceImpl<UserMapper, User>        implements UserService {    @Autowired    private UserMapper userMapper;    public boolean saveBatchByNative(List<User> list) {        return userMapper.saveBatchByNative(list);    }}```### ② 数据持久层扩展在 UserMapper 添加 saveBatchByNative 方法，实现代码如下：```import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.example.demo.model.User;import org.apache.ibatis.annotations.Mapper;import java.util.List;@Mapperpublic interface UserMapper extends BaseMapper<User> {    boolean saveBatchByNative(List<User> list);}```### ③ 添加 UserMapper.xml创建 UserMapper.xml 文件，使用 foreach 标签拼接 SQL，具体实现代码如下：```<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"><mapper namespace="com.example.demo.mapper.UserMapper">    <insert id="saveBatchByNative">        INSERT INTO `USER`(`NAME`,`PASSWORD`) VALUES        <foreach collection="list" separator="," item="item">            (#{item.name},#{item.password})        </foreach>    </insert></mapper>```经过以上步骤，我们原生的批量插入功能就实现的差不多了，接下来我们使用单元测试来查看一下此方法的执行效率。### 原生批量插入性能测试```import com.example.demo.model.User;import com.example.demo.service.impl.UserServiceImpl;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.util.ArrayList;import java.util.List;@SpringBootTestclass UserControllerTest {    // 最大循环次数    private static final int MAXCOUNT = 100000;    @Autowired    private UserServiceImpl userService;        /**     * 原生自己拼接 SQL，批量插入     */    @Test    void saveBatchByNative() {        long stime = System.currentTimeMillis(); // 统计开始时间        List<User> list = new ArrayList<>();        for (int i = 0; i < MAXCOUNT; i++) {            User user = new User();            user.setName("test:" + i);            user.setPassword("123456");            list.add(user);        }        // 批量插入        userService.saveBatchByNative(list);        long etime = System.currentTimeMillis(); // 统计结束时间        System.out.println("执行时间：" + (etime - stime));    }}```然而，当我们运行程序时却发生了以下情况：![](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-jiantmybatisplcrdzffwtsjsyforeachjxm-a9007c24-5db5-46fc-9d64-fb721184817b.jpg)纳尼？程序的执行竟然报错了。### 缺点分析从上述报错信息可以看出，当我们使用原生方法将 10W 条数据拼接成一个 SQL 执行时，由于拼接的 SQL 过大（4.56M）从而导致程序执行报错，因为默认情况下 MySQL 可以执行的最大 SQL（大小）为 4M，所以程序就报错了。这就是原生批量插入方法的缺点，也是为什么 MP 需要分批执行的原因，就是为了防止程序在执行时，因为触发了数据库的最大执行 SQL 而导致程序执行报错。#### 解决方案当然我们也可以通过设置 MySQL 的最大执行 SQL 来解决报错的问题，设置命令如下：```-- 设置最大执行 SQL 为 10Mset global max_allowed_packet=10*1024*1024;```如下图所示：![](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-jiantmybatisplcrdzffwtsjsyforeachjxm-c2ce0dc0-3791-4d7c-8f05-c96246700438.jpg)> 注意：以上命令需要在 MySQL 连接的客户端中执行。但以上解决方案仍是治标不治本，因为我们无法预测程序中最大的执行 SQL 到底有多大，那么最普世的方法就是分配执行批量插入的方法了（也就是像 MP 实现的那样）。当我们将 MySQL 的最大执行 SQL 设置为 10M 之后，运行以上单元测试代码，执行的结果如下：![](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-jiantmybatisplcrdzffwtsjsyforeachjxm-a701da82-ba81-4715-9c24-4b9aaa6594ec.jpg)## 总结本文我们介绍了 MyBatis 批量插入的 3 种方法，其中循环单次插入的性能最低，也是最不可取的；使用 MyBatis 拼接原生 SQL 一次性插入的方法性能最高，但此方法可能会导致程序执行报错（触发了数据库最大执行 SQL 大小的限制），所以综合以上情况，可以考虑使用 MP 的批量插入功能。* * ***微信8.0将好友放开到了一万，小伙伴可以加我大号了，先到先得，再满就真没了****扫描下方二维码即可加我微信啦，`2022，抱团取暖，一起牛逼。`**![](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-jiantmybatisplcrdzffwtsjsyforeachjxm-700e6458-ee4b-469c-ba22-063b303d6b5e.jpg)## 推荐阅读*   [4 种微服务配置中心技术选型，yyds！](https://mp.weixin.qq.com/s?__biz=MzU1Nzg4NjgyMw==&mid=2247502973&idx=1&sn=171e2cb9b0c3f6f244aa5727c36ba796&scene=21#wechat_redirect)*   [放弃FastDFS！SpringBoot整合MinIO实现分布式文件服务，真香！](https://mp.weixin.qq.com/s?__biz=MzU1Nzg4NjgyMw==&mid=2247502966&idx=1&sn=43490aa0563c97e1647112e671499697&scene=21#wechat_redirect)*   [看了我常用的IDEA插件，同事也开始悄悄安装了...](https://mp.weixin.qq.com/s?__biz=MzU1Nzg4NjgyMw==&mid=2247502905&idx=1&sn=fbe18f29585f57fac3a9b2450a5a2d66&scene=21#wechat_redirect)*   [技术总监亲自上阵，手撸了个电商可视化面板，产品经理惊呆了。。。](https://mp.weixin.qq.com/s?__biz=MzU1Nzg4NjgyMw==&mid=2247502786&idx=1&sn=331e34d3a03e94306c8637c65e86aae0&scene=21#wechat_redirect)*   [换掉Typora！这款支持云端同步的开源笔记应用，太炫酷了！](https://mp.weixin.qq.com/s?__biz=MzU1Nzg4NjgyMw==&mid=2247502723&idx=1&sn=82a1ee739178f5abe69deed34e758951&scene=21#wechat_redirect)*   [还在手写SQL实现？试试MyBatis-Plus同款IDEA插件吧！](https://mp.weixin.qq.com/s?__biz=MzU1Nzg4NjgyMw==&mid=2247502551&idx=1&sn=5017e6bf5b9aaabebcad8fb9f3fc7d89&scene=21#wechat_redirect)*   [重磅更新！Mall实战教程全面升级，瞬间高大上了！](https://mp.weixin.qq.com/s?__biz=MzU1Nzg4NjgyMw==&mid=2247499376&idx=1&sn=3ed28795cdd35fbaa3506e74a56703b0&scene=21#wechat_redirect)*   [40K+Star！Mall电商实战项目开源回忆录！](https://mp.weixin.qq.com/s?__biz=MzU1Nzg4NjgyMw==&mid=2247486684&idx=1&sn=807fd808adac8019eb2095ba088efe54&scene=21#wechat_redirect)![](http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-jiantmybatisplcrdzffwtsjsyforeachjxm-f56912cd-115c-4f76-88e2-9cb2b4386ce5.jpg)>参考链接：[https://mp.weixin.qq.com/s?__biz=MzU1Nzg4NjgyMw==&mid=2247502982&idx=1&sn=db9beac3eedacc587392d7b1800c752b&chksm=fc2c708ecb5bf99803a64716c6ccf77fcf116697cce40bbbfb993f9ee05eb47efeb72af359fd#rd](https://mp.weixin.qq.com/s?__biz=MzU1Nzg4NjgyMw==&mid=2247502982&idx=1&sn=db9beac3eedacc587392d7b1800c752b&chksm=fc2c708ecb5bf99803a64716c6ccf77fcf116697cce40bbbfb993f9ee05eb47efeb72af359fd#rd)，出处：macrozheng，整理：沉默王二